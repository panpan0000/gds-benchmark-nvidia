#!/usr/bin/env python3
"""
Plot all points from a summary CSV and optionally overlay a Pareto frontier.

This script is designed to work with the CSV generated by tools/compare_offloading.py
(e.g., media_compare.csv or network_compare.csv). It does NOT modify existing plot scripts.

Usage examples:
- Plot all points for prefill TTFT vs throughput with Pareto overlay:
  python3 tools/plot_pareto.py media_compare.csv \
    --x mean_ttft_ms --y total_token_throughput --phase prefill \
    --out plots/media_pareto_prefill.png --pareto \
    --frontier-csv plots/media_pareto_prefill_frontier.csv

- Network-focused plot (GDS only), TTFT vs throughput:
  python3 tools/plot_pareto.py network_compare.csv \
    --x mean_ttft_ms --y total_token_throughput --phase prefill \
    --filter-modality GDS --out plots/network_pareto_prefill.png --pareto

Options:
- --x, --y: choose metrics to plot (columns from CSV), e.g., mean_ttft_ms, total_token_throughput
- --phase: filter by phase (prefill, prefill+decode); default: no filter
- --filter-modality, --filter-bandwidth, --filter-direction, --filter-arcc:
  optional filters; multiple values accepted.
- --pareto: compute and overlay Pareto frontier (minimize X, maximize Y)
- --frontier-csv: save frontier points to a CSV (even if matplotlib is unavailable)
- --xscale, --yscale: axis scales (linear/log)

If matplotlib is not available, the script will still compute and save the frontier
if --frontier-csv is provided.
"""

import argparse
import csv
import os
from typing import Dict, List, Tuple, Optional


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Scatter plot with optional Pareto frontier overlay")
    p.add_argument("csv_path", help="Path to input CSV (e.g., media_compare.csv)")
    p.add_argument("--x", default="mean_ttft_ms", help="X axis metric column")
    p.add_argument("--y", default="total_token_throughput", help="Y axis metric column")
    p.add_argument("--phase", default=None, help="Filter by phase (prefill or prefill+decode)")
    p.add_argument("--filter-modality", nargs="*", default=None, help="Filter by modality (HBM, CPU, Local Disk, GDS)")
    p.add_argument("--filter-bandwidth", nargs="*", default=None, help="Filter by bandwidth (e.g., 400g, 800g)")
    p.add_argument("--filter-direction", nargs="*", default=None, help="Filter by direction (EW, NS, N/A or NA)")
    p.add_argument("--filter-arcc", nargs="*", default=None, help="Filter by arcc (Y or N)")
    p.add_argument("--pareto", action="store_true", help="Compute and overlay Pareto frontier (minimize X, maximize Y)")
    p.add_argument("--frontier-csv", default=None, help="Output CSV for Pareto frontier points")
    p.add_argument("--out", default="plots/pareto.png", help="Output PNG path for the plot")
    p.add_argument("--xscale", default="linear", choices=["linear", "log"], help="X axis scale")
    p.add_argument("--yscale", default="linear", choices=["linear", "log"], help="Y axis scale")
    p.add_argument("--xmin", type=float, default=None, help="Lower limit for X axis (e.g., 10)")
    p.add_argument("--xmax", type=float, default=None, help="Upper limit for X axis (e.g., 100000)")
    # 前沿覆盖显示（默认不绘制，仅计算以便输出CSV）
    p.add_argument("--overlay-frontier", action="store_true", help="Overlay Pareto frontier on the scatter plot")
    # 连线设置：按组连接点（如 modality 或 bandwidth）
    p.add_argument("--connect-by", choices=["modality","bandwidth","direction","arcc","kvcache","input_len"], default=None,
                   help="Connect points within each group by ascending X (e.g., modality/bandwidth/input_len)")
    p.add_argument("--connect-lw", type=float, default=1.2, help="Line width for group connections")
    p.add_argument("--connect-alpha", type=float, default=0.5, help="Alpha for group connections")
    p.add_argument("--connect-style", default='-', help="Line style for group connections (e.g., '-', '--', ':')")
    # 图幅与外置图例留白控制
    p.add_argument("--figwidth", type=float, default=16.0, help="Figure width in inches")
    p.add_argument("--figheight", type=float, default=8.0, help="Figure height in inches")
    p.add_argument("--legend-right", type=float, default=0.95, help="Right margin reserved for legends (0~1)")
    return p.parse_args()


def _read_rows(csv_path: str) -> List[Dict]:
    rows: List[Dict] = []
    with open(csv_path, "r", newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            rows.append(row)
    return rows


def _float(val: Optional[str]) -> Optional[float]:
    if val is None:
        return None
    s = str(val).strip()
    if s == "" or s.upper() == "N/A":
        return None
    try:
        return float(s)
    except Exception:
        return None


def _normalize_direction(d: str) -> str:
    s = (d or "").strip()
    if s in ("东西向", "EW"):
        return "EW"
    if s in ("南北向", "NS"):
        return "NS"
    if s in ("N/A", "NA", ""):
        return "NA"
    return s


def filter_rows(rows: List[Dict], args: argparse.Namespace) -> List[Dict]:
    out: List[Dict] = []
    for r in rows:
        if args.phase and (r.get("phase", None) != args.phase):
            continue

        if args.filter_modality and r.get("modality", None) not in args.filter_modality:
            continue

        if args.filter_bandwidth and r.get("bandwidth", None) not in args.filter_bandwidth:
            continue

        # normalize direction before filtering
        r_dir = _normalize_direction(r.get("direction", None))
        if args.filter_direction and r_dir not in args.filter_direction:
            continue

        if args.filter_arcc and r.get("arcc", None) not in args.filter_arcc:
            continue

        # ensure metrics present
        x = _float(r.get(args.x, None))
        y = _float(r.get(args.y, None))
        if x is None or y is None:
            continue
        r["_x"] = x
        r["_y"] = y
        r["_dir"] = r_dir
        out.append(r)
    return out


def pareto_frontier(points: List[Tuple[float, float]]) -> List[Tuple[float, float]]:
    """
    Compute Pareto frontier for 2D (minimize x, maximize y).
    Returns the nondominated points sorted by ascending x with non-increasing y.
    """
    # Remove duplicates
    unique = sorted(set(points), key=lambda p: (p[0], -p[1]))
    frontier: List[Tuple[float, float]] = []
    best_y = -float("inf")
    # Iterate by ascending x; keep points with y strictly better than seen so far
    for x, y in unique:
        if y > best_y:
            frontier.append((x, y))
            best_y = y
    return frontier


def save_frontier_csv(path: str, rows: List[Dict], frontier: List[Tuple[float, float]], xkey: str, ykey: str) -> None:
    os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
    # map (x,y) -> subset rows
    index: Dict[Tuple[float, float], List[Dict]] = {}
    for r in rows:
        key = (r["_x"], r["_y"])
        index.setdefault(key, []).append(r)
    fieldnames = list(rows[0].keys()) if rows else []
    # ensure x/y keys present
    for k in ["_x", "_y", xkey, ykey]:
        if k not in fieldnames:
            fieldnames.append(k)
    with open(path, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames)
        w.writeheader()
        for x, y in frontier:
            for r in index.get((x, y), []):
                w.writerow(r)


def plot_points(rows: List[Dict], args: argparse.Namespace, frontier: Optional[List[Tuple[float, float]]] = None) -> None:
    try:
        import matplotlib.pyplot as plt
        from matplotlib.lines import Line2D
    except Exception as e:
        print(f"Warn: matplotlib not available, skip plotting: {e}")
        return

    # Color by modality; marker by bandwidth
    colors = {
        "HBM": "tab:blue",
        "CPU": "tab:orange",
        "Local Disk": "tab:green",
        "GDS": "tab:red",
    }
    markers = {
        "400g": "o",
        "800g": "s",
        "N/A": "^",
        "NA": "^",
        "": ".",
    }

    fig, ax = plt.subplots(figsize=(args.figwidth, args.figheight))
    # 为右侧外置图例预留空间
    try:
        fig.subplots_adjust(right=args.legend_right)
    except Exception:
        pass
    # 绘制散点
    for r in rows:
        c = colors.get(r.get("modality", ""), "tab:gray")
        m = markers.get(r.get("bandwidth", ""), ".")
        ax.scatter(r["_x"], r["_y"], c=c, marker=m, s=20, alpha=0.65)

    # 帕累托前沿：用黑色虚线加星形标记高亮
    pareto_handle = None
    # 仅在用户显式要求时覆盖绘制帕累托前沿
    if frontier and args.overlay_frontier:
        fx = [p[0] for p in frontier]
        fy = [p[1] for p in frontier]
        ax.plot(fx, fy, color="black", linewidth=2.5, linestyle="--")
        ax.scatter(fx, fy, color="black", s=35, marker="*")
        pareto_handle = Line2D([0], [0], color="black", linestyle="--", marker="*", lw=2.5, label="Pareto frontier")

    # 轴与标题
    ax.set_xlabel(args.x)
    ax.set_ylabel(args.y)
    ax.set_xscale(args.xscale)
    ax.set_yscale(args.yscale)
    # 坐标轴从0开始，避免负数
    if args.xmax is not None:
        ax.set_xlim(left=0, right=args.xmax)
    elif args.xmin is not None:
        ax.set_xlim(left=max(0, args.xmin))
    else:
        ax.set_xlim(left=0)
    ax.set_ylim(bottom=0)
    title = f"Scatter of {args.x} vs {args.y}"
    if args.phase:
        title += f" ({args.phase})"
    ax.set_title(title)
    ax.grid(True, linestyle="--", alpha=0.3)

    # 构造图例：介质与带宽各一组
    modality_proxies = [
        Line2D([0],[0], marker='o', color='w', label=mod, markerfacecolor=colors.get(mod, 'tab:gray'), markersize=8)
        for mod in ["HBM", "CPU", "Local Disk", "GDS"]
    ]
    bandwidth_proxies = [
        Line2D([0],[0], marker=markers.get(bw, '.'), color='gray', label=bw or 'unknown', linestyle='')
        for bw in ["400g", "800g", "N/A"]
    ]

    # 第一图例：介质
    # 图例放到图表内右侧（颜色与形状）
    legend1 = ax.legend(handles=modality_proxies, title="Modality", loc="upper right")
    ax.add_artist(legend1)
    handles2 = bandwidth_proxies
    if pareto_handle:
        handles2 = handles2 + [pareto_handle]
    legend2 = ax.legend(handles=handles2, title="Bandwidth / Frontier", loc="lower right")
    ax.add_artist(legend2)

    # 按组连接点（可选）
    if args.connect_by:
        # 分组
        groups: Dict[str, List[Dict]] = {}
        for r in rows:
            key = str(r.get(args.connect_by, ''))
            groups.setdefault(key, []).append(r)

        # 为每个分组分配可区分的颜色
        palette = ['tab:blue','tab:orange','tab:green','tab:red','tab:purple','tab:brown','tab:pink','tab:olive','tab:cyan','tab:gray']
        group_colors: Dict[str, str] = {}
        if args.connect_by == 'modality':
            for k in groups.keys():
                group_colors[k] = colors.get(k, 'tab:gray')
        elif args.connect_by == 'bandwidth':
            mapping = {'400g':'tab:blue','800g':'tab:orange','N/A':'tab:gray','NA':'tab:gray','':'tab:gray'}
            for k in groups.keys():
                group_colors[k] = mapping.get(k, palette[hash(k)%len(palette)])
        elif args.connect_by == 'direction':
            mapping = {'EW':'tab:purple','NS':'tab:olive','NA':'tab:gray','N/A':'tab:gray','':'tab:gray'}
            for k in groups.keys():
                group_colors[k] = mapping.get(k, palette[hash(k)%len(palette)])
        else:
            # input_len / arcc / kvcache 等任意键，使用稳定的调色板分配
            for i, k in enumerate(sorted(groups.keys(), key=lambda x: (len(x), x))):
                group_colors[k] = palette[i % len(palette)]

        # 绘制每组连线，按X升序连接
        conn_handles = []
        for key, items in groups.items():
            items.sort(key=lambda rr: rr["_x"])
            xs = [rr["_x"] for rr in items]
            ys = [rr["_y"] for rr in items]
            line_color = group_colors.get(key, 'tab:gray')
            ax.plot(xs, ys, linestyle=args.connect_style, linewidth=args.connect_lw, alpha=args.connect_alpha, color=line_color)
            conn_handles.append(Line2D([0],[0], color=line_color, lw=args.connect_lw, linestyle=args.connect_style, label=f"{args.connect_by}={key}"))

        # 第三图例：连接线分组颜色（放到图表下方居中）
        ncols = max(1, min(len(conn_handles), 5))
        conn_legend = fig.legend(handles=conn_handles, title=f"Connections by {args.connect_by}",
                                 loc="lower center", ncol=ncols, bbox_to_anchor=(0.5, -0.02))

    os.makedirs(os.path.dirname(args.out) or ".", exist_ok=True)
    fig.tight_layout()
    # 适当增大边距，避免底部图例被截断
    fig.savefig(args.out, bbox_inches='tight', pad_inches=0.6)
    plt.close(fig)
    print(f"Plot saved to {args.out}")


def main():
    args = parse_args()
    rows = _read_rows(args.csv_path)
    rows = filter_rows(rows, args)
    if not rows:
        print("No rows to plot after filtering.")
        return

    frontier: Optional[List[Tuple[float, float]]] = None
    if args.pareto:
        pts = [(r["_x"], r["_y"]) for r in rows]
        frontier = pareto_frontier(pts)
        if args.frontier_csv:
            save_frontier_csv(args.frontier_csv, rows, frontier, args.x, args.y)
            print(f"Frontier CSV saved to {args.frontier_csv}")

    plot_points(rows, args, frontier)


if __name__ == "__main__":
    main()